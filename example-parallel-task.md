# Example: Parallel Emergency Protocol UI Enhancement

## Copy and paste this into Claude Code for parallel agent execution:

---

# Parallel SwiftUI Development Task - Emergency Protocol Enhancement

I need to enhance the Emergency Protocol UI in RapidResponseCentral with better accessibility, performance, and user experience. Please coordinate these tasks in parallel using the BMAD method.

## Context
- Project: RapidResponseCentral (iOS medical reference app)
- Target: Emergency Protocol UI components
- Architecture: SwiftUI with MVVM, Swift Package Manager
- Location: `RapidResponseCentralPackage/Sources/RapidResponseCentralFeature/`

## B - Brainstorm Phase (Parallel Ideation)

### Task 1: Architecture Brainstorm (system-architect)
Review the current SwiftUI architecture in the Emergency Protocol views and brainstorm improvements:
- Analyze `Views/EmergencyHomeView.swift` and `Views/ProtocolDetailView.swift`
- Suggest MVVM pattern optimizations
- Brainstorm state management improvements
- Consider performance architecture patterns

### Task 2: Design Brainstorm (ui-designer)
Brainstorm UI/UX improvements for the Emergency Protocol interface:
- Analyze current visual design and accessibility
- Brainstorm medical-grade design patterns
- Suggest responsive layout improvements
- Consider emergency situation UX patterns

### Task 3: Feature Brainstorm (trend-researcher)
Research and brainstorm new features for Emergency Protocols:
- Research medical app trends and best practices
- Brainstorm additional protocol features
- Suggest integration opportunities
- Consider user workflow improvements

## M - Map Phase (Parallel Planning)

### Task 4: Data Architecture Mapping (backend-architect)
Map the data flow and service architecture:
- Review `Services/EmergencyProtocolService.swift`
- Map data model relationships
- Plan concurrency improvements
- Design service optimization strategies

### Task 5: Build Pipeline Mapping (devops-automator)
Map the development and deployment pipeline:
- Analyze current build configuration
- Map testing strategies
- Plan CI/CD improvements
- Design deployment optimization

## A - Act Phase (Parallel Implementation)

### Task 6: SwiftUI Implementation (coder)
Implement the planned improvements:
- Update Emergency Protocol views with optimizations
- Implement accessibility improvements
- Add performance optimizations
- Integrate new features

### Task 7: Rapid Prototyping (rapid-prototyper)
Create rapid prototypes for new features:
- Prototype new UI components
- Create experimental features
- Test new interaction patterns
- Validate design concepts

### Task 8: Native Feature Building (mobile-app-builder)
Build native iOS features and optimizations:
- Implement native iOS features
- Optimize for iOS performance
- Add platform-specific enhancements
- Ensure iOS best practices

## D - Decide Phase (Parallel Validation)

### Task 9: Test Creation and Execution (tester)
Create and run comprehensive tests:
- Write XCTest unit tests for services
- Create UI tests for protocol flow
- Test accessibility features
- Validate all functionality

### Task 10: Performance Validation (performance-benchmarker)
Validate performance improvements:
- Benchmark memory usage
- Test rendering performance
- Validate optimization effectiveness
- Ensure performance targets are met

### Task 11: Build and Deployment Validation (production-validator)
Validate the complete build and deployment:
- Build the app in Xcode
- Test in iOS Simulator
- Validate all Emergency Protocol features
- Check for build issues and conflicts

## Coordination Instructions

**CRITICAL: Execute all tasks in parallel, not sequentially!**

1. **Parallel Execution**: All 11 tasks should run simultaneously
2. **Shared Memory**: Use shared memory for cross-agent communication
3. **Coordination**: Agents should coordinate through comments and shared findings
4. **Conflict Resolution**: Resolve any architectural or design conflicts through discussion
5. **Progress Tracking**: Each agent should report progress and findings

## Expected Outcomes

After parallel execution, we should have:
- Optimized Emergency Protocol UI architecture
- Enhanced accessibility and user experience
- Improved performance and memory usage
- Comprehensive test coverage
- Validated build and deployment
- New feature prototypes and ideas

## Memory Coordination

Set up these shared memory keys for cross-agent communication:
- `emergency-protocol/architecture-improvements`
- `emergency-protocol/ui-enhancements`
- `emergency-protocol/performance-optimizations`
- `emergency-protocol/test-results`
- `emergency-protocol/build-validation`

**Execute all tasks now in parallel!**

---

## How to Use This Example

1. **Copy the entire content above**
2. **Paste it into Claude Code**
3. **Send the message**
4. **All agents will execute simultaneously**

## Expected Behavior

You should see:
- Multiple agents working simultaneously
- Cross-references between agent outputs
- Shared memory updates
- Coordinated results
- Faster overall execution time

## Troubleshooting

If agents still run sequentially:
1. Add "PARALLEL EXECUTION REQUIRED" at the top
2. Use more explicit parallel keywords
3. Break tasks into smaller, independent chunks
4. Add coordination hooks between tasks

This example demonstrates the proper way to invoke multiple agents in parallel for SwiftUI development. 